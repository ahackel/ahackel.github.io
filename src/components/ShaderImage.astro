---
export interface Props {
  src: string;
  shader?: string;
}

const { src, shader } = Astro.props;
---

<shader-image data-src={src} data-shader={shader}>
  <canvas id="canvas"></canvas>
</shader-image>

<script>
  class ShaderImage extends HTMLElement {
    constructor() {
      super();

      const src = this.dataset.src;
      const canvas = this.querySelector<HTMLCanvasElement>("canvas");

      // Get canvas and WebGL context
      const gl = (canvas.getContext("webgl2", { premultipliedAlpha: false }) ||
          canvas.getContext("webgl", { premultipliedAlpha: false }));


      // Set canvas size
      canvas.width = 512;
      canvas.height = 512;

      // Vertex shader source
      const vertexShaderSource = `
attribute vec4 a_position;
attribute vec2 a_texCoord;

varying vec2 v_texCoord;

void main() {
  gl_Position = a_position;
  v_texCoord = a_texCoord;
}
`;

      // Fragment shader source
      const fragmentShaderSource= this.dataset.shader ?? `
precision mediump float;

uniform sampler2D u_image;
varying vec2 v_texCoord;

void main() {
    vec4 color = texture2D(u_image, v_texCoord);
    gl_FragColor = color;  
}
`;

      // Create, compile, and attach the shaders
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }

      const vertexShader = createShader(
        gl,
        gl.VERTEX_SHADER,
        vertexShaderSource
      );
      const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        fragmentShaderSource
      );

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      // Set up vertex data (positions and texture coordinates)
      const vertices = new Float32Array([
        -1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, 1, 1, 1, 0,
      ]);

      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const a_position = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(a_position);
      gl.vertexAttribPointer(
        a_position,
        2,
        gl.FLOAT,
        false,
        4 * Float32Array.BYTES_PER_ELEMENT,
        0
      );

      const a_texCoord = gl.getAttribLocation(program, "a_texCoord");
      gl.enableVertexAttribArray(a_texCoord);
      gl.vertexAttribPointer(
        a_texCoord,
        2,
        gl.FLOAT,
        false,
        4 * Float32Array.BYTES_PER_ELEMENT,
        2 * Float32Array.BYTES_PER_ELEMENT
      );

      // Create and load the texture
      const image = new Image();
      image.src = src;
      image.onload = () => {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          image
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        // Set texture uniform
        const u_image = gl.getUniformLocation(program, "u_image");
        gl.uniform1i(u_image, 0);

        requestAnimationFrame(render);
      };

      const timeLocation = gl.getUniformLocation(program, "time");

      function render(time){
        gl.uniform1f(timeLocation, time * 0.001);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);  
      }

      // Error handling
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(vertexShader));
      }

      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(fragmentShader));
      }

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
      }
    }
  }

  customElements.define('shader-image', ShaderImage);
</script>

<style>
  canvas {
      width: 20rem;
      margin: 0 auto;
      display: block;
      /*border-radius: 100%;*/
  }
</style>
